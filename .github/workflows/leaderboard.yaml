name: Leaderboard - recent committers (ytumatmuh)

on:
  workflow_dispatch:
    inputs:
      username:
        description: 'GitHub username to aggregate (default: ytumatmuh)'
        required: false
        default: 'ytumatmuh'
  schedule:
    - cron: '0 8 * * 1' # weekly on Mondays at 08:00 UTC (optional)

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate leaderboard image (fetch public events + QuickChart)
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs').promises;
            // Analyze organization 'ytumatmuh' for commits in the last 7 days
            const org = 'ytumatmuh';
            const since = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();

            // fetch public repos for the org
            const repos = await github.paginate(github.rest.repos.listForOrg, { org, type: 'public', per_page: 100 });

            const repoCounts = {}; // repo -> commit count
            const authorCounts = {}; // author -> commit count
            const repoAuthors = {}; // repo -> { author -> count }

            for (const r of repos) {
              if (r.archived) continue;
              const name = r.name;
              // list commits in the last week
              let commits = [];
              try {
                commits = await github.paginate(github.rest.repos.listCommits, { owner: org, repo: name, since, per_page: 100 });
              } catch (e) {
                console.log(`skip repo ${name} due to error listing commits:`, e.message || e);
                continue;
              }
              if (!commits || commits.length === 0) continue;
              repoCounts[name] = commits.length;
              repoAuthors[name] = repoAuthors[name] || {};
              for (const c of commits) {
                const authorName = (c.commit && c.commit.author && c.commit.author.name) || (c.author && c.author.login) || (c.commit && c.commit.author && c.commit.author.email) || c.sha;
                authorCounts[authorName] = (authorCounts[authorName] || 0) + 1;
                repoAuthors[name][authorName] = (repoAuthors[name][authorName] || 0) + 1;
              }
            }

            const repoItems = Object.keys(repoCounts).map(rn => ({ repo: rn, commits: repoCounts[rn] }));
            repoItems.sort((a,b) => b.commits - a.commits);

            const authorItems = Object.keys(authorCounts).map(a => ({ author: a, commits: authorCounts[a] }));
            authorItems.sort((a,b) => b.commits - a.commits);

            const topRepos = repoItems.slice(0, 20);
            const topAuthors = authorItems.slice(0, 20);

            // Build markdown table
            const mdLines = [];
            mdLines.push(`# Weekly commit leaderboard for org: ${org}`);
            mdLines.push(`_Period start:_ ${since}`);
            mdLines.push('');
            mdLines.push('## Top repositories (by commits in last 7 days)');
            mdLines.push('| Repo | Commits |');
            mdLines.push('| --- | ---: |');
            for (const r of topRepos) mdLines.push(`| ${r.repo} | ${r.commits} |`);
            mdLines.push('');
            mdLines.push('## Top contributors (by commits in last 7 days)');
            mdLines.push('| Author | Commits |');
            mdLines.push('| --- | ---: |');
            for (const a of topAuthors) mdLines.push(`| ${a.author} | ${a.commits} |`);
            mdLines.push('');
            mdLines.push('## Per-repo contributor breakdown (top 5 per repo)');
            for (const r of topRepos) {
              mdLines.push(`### ${r.repo} — ${r.commits} commits`);
              mdLines.push('| Author | Commits |');
              mdLines.push('| --- | ---: |');
              const entries = Object.keys(repoAuthors[r.repo] || {}).map(k => ({ author: k, commits: repoAuthors[r.repo][k] }));
              entries.sort((a,b) => b.commits - a.commits);
              for (const e of entries.slice(0,5)) mdLines.push(`| ${e.author} | ${e.commits} |`);
              mdLines.push('');
            }

            const md = mdLines.join('\n');
            await fs.writeFile('leaderboard_weekly.md', md);
            await fs.writeFile('leaderboard_weekly.json', JSON.stringify({ generated_at: new Date().toISOString(), since, org, topRepos, topAuthors, repoAuthors }, null, 2));

            // produce two charts (top repos and top authors)
            const qc = async (labels, data, title, filename) => {
              const chartConfig = { type: 'bar', data: { labels, datasets: [{ label: title, data }] }, options: { plugins: { legend: { display: false } }, title: { display: true, text: title }, scales: { y: { beginAtZero: true } } } };
              const qcResp = await fetch('https://quickchart.io/chart/create', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ chart: chartConfig, width: 1200, height: 600, backgroundColor: 'white' }) });
              const qcJson = await qcResp.json();
              const imgResp = await fetch(qcJson.url);
              const arr = await imgResp.arrayBuffer();
              await fs.writeFile(filename, Buffer.from(arr));
            };

            await qc(topRepos.map(r=>r.repo), topRepos.map(r=>r.commits), `Top repos — ${org}`, 'top_repos.png');
            await qc(topAuthors.map(a=>a.author), topAuthors.map(a=>a.commits), `Top authors — ${org}`, 'top_authors.png');

            console.log('Generated leaderboard_weekly.md, leaderboard_weekly.json, top_repos.png, top_authors.png');

      - name: Upload leaderboard artifacts
        uses: actions/upload-artifact@v4
        with:
          name: leaderboard
          path: |
            leaderboard_weekly.md
            leaderboard_weekly.json
            top_repos.png
            top_authors.png

      - name: Print quick summary
        run: |
          echo "Generated leaderboard - see leaderboard_weekly.json";
          cat leaderboard_weekly.json
